<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word War GRE</title>
    <!-- Tailwind CSS CDN for quick styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font for retro pixelated look -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000; /* Deep black for arcade feel */
            color: #E0E0E0; /* Light grey for text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrollbars */
            background-image:
                linear-gradient(rgba(0, 255, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px; /* Subtle green grid */
        }

        /* Scanline effect for retro display */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.25) 50%), linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 100% 2px, 2px 100%;
            pointer-events: none; /* Allow clicks through */
            z-index: 1000; /* Ensure it's on top */
        }


        .game-container {
            background-color: #0F0F0F; /* Dark grey for console */
            border: 8px solid #00FF00; /* Neon green border */
            border-radius: 15px;
            padding: 40px;
            box-shadow:
                0 0 30px #00FF00, /* Stronger neon green glow */
                0 0 60px #FF00FF, /* Vibrant magenta secondary glow */
                inset 0 0 20px rgba(255, 255, 255, 0.3); /* Inner highlight */
            max-width: 95%;
            width: 900px; /* Wider for better 1v1 layout */
            text-align: center;
            position: relative;
            animation: pulse-border 1.5s infinite alternate; /* Faster pulse */
        }

        @keyframes pulse-border {
            from {
                border-color: #00FF00;
                box-shadow: 0 0 30px #00FF00, 0 0 60px #FF00FF, inset 0 0 20px rgba(255, 255, 255, 0.3);
            }
            to {
                border-color: #00FFFF; /* Aqua */
                box-shadow: 0 0 40px #00FFFF, 0 0 80px #FFFF00, inset 0 0 25px rgba(255, 255, 255, 0.4); /* Yellow */
            }
        }

        h1 {
            color: #FFFF00; /* Bright yellow */
            text-shadow: 4px 4px #FF00FF; /* Magenta shadow */
            font-size: 3.5rem;
            margin-bottom: 25px;
            text-transform: uppercase;
        }

        h2 {
            color: #00FF00; /* Bright green */
            text-shadow: 2px 2px #00FFFF; /* Aqua shadow */
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        button {
            background-color: #FF00FF; /* Magenta */
            color: #FFFFFF;
            padding: 18px 35px;
            border: 5px solid #00FF00; /* Neon green border */
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
            text-shadow: 2px 2px #000;
            box-shadow: 0 8px #8B008B; /* Darker purple shadow for depth */
            margin: 15px;
            outline: none;
            position: relative;
            top: 0;
            left: 0;
            letter-spacing: 1px;
        }

        button:hover {
            background-color: #FFFF00; /* Yellow on hover */
            color: #000;
            border-color: #00FFFF; /* Aqua border */
            box-shadow: 0 10px #FFD700; /* Gold shadow */
            transform: translateY(-3px) scale(1.02);
        }

        button:active {
            background-color: #8B008B; /* Dark magenta on click */
            box-shadow: 0 3px #4B0082; /* Indigo shadow */
            transform: translateY(5px) scale(0.98);
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Game specific styles */
        #score-display, #wrong-attempts-display {
            font-size: 1.8rem;
            margin: 10px 0;
            color: #FFFF00; /* Yellow */
            text-shadow: 2px 2px #000;
        }

        #wrong-attempts-display {
            color: #FF0000; /* Bright red */
        }

        #word-display {
            font-size: 2.8rem;
            font-weight: bold;
            color: #00FF00; /* Neon green */
            margin-bottom: 40px;
            text-shadow: 4px 4px #00FFFF; /* Aqua shadow */
            word-wrap: break-word;
            transition: color 0.1s ease-in-out, text-shadow 0.1s ease-in-out;
            min-height: 80px; /* Ensure space for feedback */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #word-display.correct-feedback {
            color: #00FF00; /* Bright green */
            text-shadow: 0 0 15px #00FF00, 0 0 30px #00FF00;
        }

        #word-display.wrong-feedback {
            color: #FF0000; /* Bright red */
            text-shadow: 0 0 15px #FF0000, 0 0 30px #FF0000;
        }

        .choices-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px; /* Increased gap */
            margin-top: 30px;
        }

        @media (min-width: 640px) {
            .choices-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        .choice-button {
            background-color: #0000FF; /* Electric blue */
            border: 5px solid #FFFF00; /* Yellow border */
            color: #FFFFFF;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: left;
            word-wrap: break-word;
            min-height: 100px; /* Taller buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px #0000A0; /* Darker blue shadow */
        }

        .choice-button:hover {
            background-color: #00FFFF; /* Aqua on hover */
            border-color: #FF00FF; /* Magenta border on hover */
            box-shadow: 0 8px #008B8B; /* Darker aqua shadow */
        }

        #leaderboard-table {
            width: 100%;
            margin-top: 30px;
            border-collapse: collapse;
            font-size: 1.2rem;
        }

        #leaderboard-table th, #leaderboard-table td {
            border: 3px solid #00FF00; /* Neon green border */
            padding: 12px;
            text-align: left;
            color: #E0E0E0;
        }

        #leaderboard-table th {
            background-color: #0000FF; /* Electric blue header */
            color: #FFFF00;
            text-shadow: 1px 1px #000;
        }

        #leaderboard-table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.3);
        }

        input[type="text"], input[type="number"] {
            background-color: #1A1A1A; /* Dark background */
            border: 3px solid #00FF00; /* Neon green border */
            color: #FFFF00;
            font-family: 'Press Start 2P', cursive;
            padding: 12px;
            font-size: 1.1rem;
            border-radius: 8px;
            width: calc(100% - 28px);
            max-width: 350px;
            margin-top: 15px;
            text-align: center;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #FF00FF;
            box-shadow: 0 0 15px #FF00FF;
        }

        /* Custom Modal Styles (unchanged, but styled with new colors) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .modal-content {
            background-color: #0F0F0F;
            border: 8px solid #FF00FF; /* Magenta border */
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            box-shadow: 0 0 40px #FF00FF, inset 0 0 20px rgba(255, 255, 255, 0.4);
            max-width: 600px;
            width: 90%;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.4rem;
            color: #E0E0E0;
            position: relative;
            animation: modal-pop-in 0.3s ease-out;
        }

        .modal-content h3 {
            color: #FFFF00;
            font-size: 2.2rem;
            margin-bottom: 25px;
            text-shadow: 2px 2px #FF00FF;
        }

        .modal-content button {
            background-color: #00FF00; /* Green */
            border-color: #FFFF00; /* Yellow */
            margin-top: 35px;
            padding: 15px 30px;
            font-size: 1.2rem;
            box-shadow: 0 6px #008000; /* Darker green */
        }

        .modal-content button:hover {
            background-color: #FFFF00; /* Yellow */
            border-color: #00FF00; /* Green */
            color: #000;
        }

        /* Multiplayer specific UI */
        .player-score-panel {
            background-color: #1A1A1A;
            border: 3px solid #00FFFF; /* Aqua border */
            border-radius: 8px;
            padding: 10px 15px;
            margin: 0 10px;
            font-size: 1.2rem;
            text-align: left;
            flex-grow: 1;
        }
        .player-score-panel strong {
            color: #FFFF00;
            text-shadow: 1px 1px #000;
        }
        .player-score-panel .score-value {
            color: #00FF00;
        }
        .player-score-panel .wrong-value {
            color: #FF0000;
        }
        .opponent-status {
            font-size: 1rem;
            color: #00FFFF;
            margin-top: 5px;
        }
        .opponent-name {
             color: #FF00FF;
        }
        .lobby-info {
            font-size: 1.4rem;
            color: #00FF00;
            margin-bottom: 20px;
            word-break: break-all;
        }

    </style>
</head>
<body>
    <!-- Background Music Placeholder -->
    <audio id="background-music" loop>
        <!-- Add your audio source here. Make sure it's a publicly accessible URL. -->
        <!-- Example: <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg"> -->
        Your browser does not support the audio element.
    </audio>

    <!-- Sound Effects Placeholders -->
    <audio id="correct-sound">
        <!-- Example: <source src="https://assets.mixkit.co/sfx/preview/mixkit-game-bonus-present-impact-2070.mp3" type="audio/mpeg"> -->
        Your browser does not support the audio element.
    </audio>
    <audio id="wrong-sound">
        <!-- Example: <source src="https://assets.mixkit.co/sfx/preview/mixkit-wrong-answer-bass-buzzer-948.mp3" type="audio/mpeg"> -->
        Your browser does not support the audio element.
    </audio>

    <div class="game-container">
        <!-- Main Menu Screen -->
        <div id="main-menu" class="screen active">
            <h1>Word War GRE</h1>
            <p class="text-lg mb-8">Test your GRE vocabulary skills!</p>
            <button id="play-solo-button">Play Solo</button>
            <button id="play-1v1-button">Play 1v1</button>
            <button id="show-leaderboard-main">Leaderboard</button>
            <button id="toggle-music-button" class="mt-4">Toggle Music</button>
        </div>

        <!-- 1v1 Lobby Screen -->
        <div id="lobby-screen" class="screen">
            <h2>1v1 Multiplayer</h2>
            <p class="text-md mb-4">Enter your player name:</p>
            <input type="text" id="player-name-1v1-input" placeholder="Your Name" value="Player1">
            <div class="mt-8">
                <button id="create-game-button">Create New Game</button>
                <button id="join-game-button">Join Existing Game</button>
            </div>
            <div id="lobby-messages" class="text-yellow-400 mt-6 text-sm"></div>
            <div id="room-id-display" class="lobby-info mt-4 hidden">Room ID: <span id="room-id-text" class="text-pink-400"></span></div>
            <button id="ready-button" class="mt-6 hidden">Ready!</button>
            <button id="leave-lobby-button" class="mt-6">Back to Main Menu</button>
        </div>

        <!-- Game Screen (Solo & 1v1) -->
        <div id="game-screen" class="screen">
            <div class="flex flex-col md:flex-row justify-between items-center mb-6">
                <!-- Player 1 (You) Score Panel -->
                <div class="player-score-panel mb-4 md:mb-0">
                    <strong>YOU (<span id="my-player-name"></span>)</strong><br>
                    Score: <span id="score-display" class="score-value">0</span><br>
                    Wrong: <span id="wrong-attempts-display" class="wrong-value">0/3</span>
                </div>
                <!-- Opponent Score Panel (1v1 only) -->
                <div id="opponent-panel" class="player-score-panel hidden">
                    <strong>OPPONENT (<span id="opponent-player-name">N/A</span>)</strong><br>
                    Score: <span id="opponent-score-display" class="score-value">0</span><br>
                    Wrong: <span id="opponent-wrong-attempts-display" class="wrong-value">0/3</span><br>
                    <span id="opponent-status" class="opponent-status"></span>
                </div>
            </div>
            <div id="word-display" class="mb-8"></div>
            <div id="choices-container" class="choices-grid">
                <!-- Choice buttons will be injected here by JavaScript -->
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <h2>GAME OVER!</h2>
            <p class="text-lg mt-4 mb-4">Your final score: <span id="final-score" class="font-bold text-yellow-400">0</span></p>
            <p id="multiplayer-results-message" class="text-xl text-cyan-400 mb-4 hidden"></p>
            <p class="text-md mb-2">Enter your name for the Leaderboard:</p>
            <input type="text" id="player-name-input" placeholder="Your Name">
            <button id="save-score-button" class="mt-4">Save Score</button>
            <button id="play-again-button">Play Again</button>
            <button id="main-menu-from-gameover">Main Menu</button>
        </div>

        <!-- Leaderboard Screen -->
        <div id="leaderboard-screen" class="screen">
            <h2>Leaderboard</h2>
            <table id="leaderboard-table" class="mx-auto">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <!-- Leaderboard entries will be injected here by JavaScript -->
                </tbody>
            </table>
            <button id="main-menu-from-leaderboard" class="mt-8">Main Menu</button>
        </div>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="custom-modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modal-title">Attention!</h3>
            <p id="modal-message"></p>
            <button id="modal-close-button">OK</button>
        </div>
    </div>

    <!-- Firebase SDK (Version 11.6.1) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Global Variables (provided by Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Global Firebase state for game logic
        window.firebaseInitialized = false;
        window.currentUserId = null;
        window.db = db; // Expose db to global scope for game logic
        window.auth = auth; // Expose auth to global scope for game logic

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                window.currentUserId = user.uid;
                console.log("Firebase: User signed in:", user.uid);
            } else {
                console.log("Firebase: No user signed in. Attempting anonymous sign-in...");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        window.currentUserId = auth.currentUser.uid;
                        console.log("Firebase: Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        window.currentUserId = auth.currentUser.uid;
                        console.log("Firebase: Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                    // Handle authentication errors, maybe show a message to the user
                    showCustomModal("Auth Error", "Could not sign in to multiplayer. Please try refreshing.");
                }
            }
            window.firebaseInitialized = true; // Mark Firebase as ready
        });

        // Expose Firestore functions to global scope
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.updateDoc = updateDoc;
        window.onSnapshot = onSnapshot;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.appId = appId; // Expose appId as well
    </script>


    <script>
        // Game Data: GRE Words and Definitions
        const words = [
            {
                word: "Acrimonious",
                definition: "Stinging, bitter in temper or tone.",
                options: [
                    "Stinging, bitter in temper or tone.",
                    "Sweet and harmonious.",
                    "Calm and collected.",
                    "Full of joy and laughter."
                ]
            },
            {
                word: "Capricious",
                definition: "Given to sudden and unaccountable changes of mood or behavior.",
                options: [
                    "Given to sudden and unaccountable changes of mood or behavior.",
                    "Stable and predictable.",
                    "Careful and cautious.",
                    "Determined and resolute."
                ]
            },
            {
                word: "Deleterious",
                definition: "Causing harm or damage.",
                options: [
                    "Causing harm or damage.",
                    "Beneficial and helpful.",
                    "Nourishing and healthy.",
                    "Pleasant and enjoyable."
                ]
            },
            {
                word: "Ephemeral",
                definition: "Lasting for a very short time.",
                options: [
                    "Lasting for a very short time.",
                    "Lasting for an eternity.",
                    "Permanent and enduring.",
                    "Slow to change."
                ]
            },
            {
                word: "Fugacious",
                definition: "Fleeting; lasting a short time.",
                options: [
                    "Fleeting; lasting a short time.",
                    "Permanent and unchangeable.",
                    "Strong and durable.",
                    "Moving very slowly."
                ]
            },
            {
                word: "Gregarious",
                definition: "Fond of company; sociable.",
                options: [
                    "Fond of company; sociable.",
                    "Reserved and quiet.",
                    "Solitary and reclusive.",
                    "Shy and introverted."
                ]
            },
            {
                word: "Harangue",
                definition: "A lengthy and aggressive speech.",
                options: [
                    "A lengthy and aggressive speech.",
                    "A brief and polite conversation.",
                    "A gentle whisper.",
                    "A soothing lullaby."
                ]
            },
            {
                word: "Ingenious",
                definition: "Clever, original, and inventive.",
                options: [
                    "Clever, original, and inventive.",
                    "Unimaginative and dull.",
                    "Simple and straightforward.",
                    "Confused and disoriented."
                ]
            },
            {
                word: "Laconic",
                definition: "Using very few words.",
                options: [
                    "Using very few words.",
                    "Talkative and verbose.",
                    "Eloquent and persuasive.",
                    "Loud and boisterous."
                ]
            },
            {
                word: "Mellifluous",
                definition: "Sweet or musical; pleasant to hear.",
                options: [
                    "Sweet or musical; pleasant to hear.",
                    "Harsh and discordant.",
                    "Loud and piercing.",
                    "Rough and abrasive."
                ]
            },
            {
                word: "Obfuscate",
                definition: "Render obscure, unclear, or unintelligible.",
                options: [
                    "Render obscure, unclear, or unintelligible.",
                    "Make clear and understandable.",
                    "Illuminate and enlighten.",
                    "Simplify and clarify."
                ]
            },
            {
                word: "Perfunctory",
                definition: "Carried out with a minimum of effort or reflection.",
                options: [
                    "Carried out with a minimum of effort or reflection.",
                    "Thorough and meticulous.",
                    "Energetic and enthusiastic.",
                    "Careful and precise."
                ]
            },
            {
                word: "Quixotic",
                definition: "Extremely idealistic; unrealistic and impractical.",
                options: [
                    "Extremely idealistic; unrealistic and impractical.",
                    "Realistic and pragmatic.",
                    "Cynical and pessimistic.",
                    "Cautious and conservative."
                ]
            },
            {
                word: "Recalcitrant",
                definition: "Having an obstinately uncooperative attitude toward authority or discipline.",
                options: [
                    "Having an obstinately uncooperative attitude toward authority or discipline.",
                    "Obedient and compliant.",
                    "Eager to cooperate.",
                    "Submissive and docile."
                ]
            },
            {
                word: "Sycophant",
                definition: "A person who acts obsequiously toward someone important in order to gain advantage.",
                options: [
                    "A person who acts obsequiously toward someone important in order to gain advantage.",
                    "An honest and straightforward person.",
                    "A true leader.",
                    "A humble and modest individual."
                ]
            }
        ];

        // Global Game State
        let currentScore = 0;
        let wrongAttempts = 0;
        let currentWord = {};
        let leaderboard = [];
        let musicPlaying = false; // Track music state
        let gameMode = 'solo'; // 'solo' or '1v1'

        // 1v1 Multiplayer State
        let gameRoomRef = null; // Firestore document reference for the current game room
        let unsubscribeGameRoom = null; // Function to unsubscribe from Firestore listener
        let currentPlayerId = null; // Will be window.currentUserId
        let myPlayerName = '';
        let opponentId = null;
        let opponentName = '';
        let myPlayerNum = 0; // 1 or 2
        let opponentPlayerNum = 0; // 1 or 2


        // DOM Elements
        const mainMenuScreen = document.getElementById('main-menu');
        const lobbyScreen = document.getElementById('lobby-screen'); // New lobby screen
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const leaderboardScreen = document.getElementById('leaderboard-screen');

        const playSoloButton = document.getElementById('play-solo-button'); // New solo play button
        const play1v1Button = document.getElementById('play-1v1-button'); // New 1v1 button
        const showLeaderboardMainMenuButton = document.getElementById('show-leaderboard-main');
        const toggleMusicButton = document.getElementById('toggle-music-button');
        const wordDisplay = document.getElementById('word-display');
        const choicesContainer = document.getElementById('choices-container');
        const scoreDisplay = document.getElementById('score-display');
        const wrongAttemptsDisplay = document.getElementById('wrong-attempts-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const multiplayerResultsMessage = document.getElementById('multiplayer-results-message'); // For 1v1 results
        const playerNameInput = document.getElementById('player-name-input'); // For solo leaderboard name
        const saveScoreButton = document.getElementById('save-score-button');
        const playAgainButton = document.getElementById('play-again-button');
        const mainMenuFromGameOverButton = document.getElementById('main-menu-from-gameover');
        const leaderboardBody = document.getElementById('leaderboard-body');
        const mainMenuFromLeaderboardButton = document.getElementById('main-menu-from-leaderboard');
        const backgroundMusic = document.getElementById('background-music');
        const correctSound = document.getElementById('correct-sound');
        const wrongSound = document.getElementById('wrong-sound');

        // Lobby elements
        const playerName1v1Input = document.getElementById('player-name-1v1-input');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const lobbyMessages = document.getElementById('lobby-messages');
        const roomIdDisplay = document.getElementById('room-id-display');
        const roomIdText = document.getElementById('room-id-text');
        const readyButton = document.getElementById('ready-button');
        const leaveLobbyButton = document.getElementById('leave-lobby-button');

        // Game screen 1v1 elements
        const myPlayerNameDisplay = document.getElementById('my-player-name');
        const opponentPanel = document.getElementById('opponent-panel');
        const opponentPlayerNameDisplay = document.getElementById('opponent-player-name');
        const opponentScoreDisplay = document.getElementById('opponent-score-display');
        const opponentWrongAttemptsDisplay = document.getElementById('opponent-wrong-attempts-display');
        const opponentStatusDisplay = document.getElementById('opponent-status');


        // Custom Modal Elements
        const customModalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseButton = document.getElementById('modal-close-button');


        // --- Utility Functions ---

        // Function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }

        // Function to generate a random 4-digit room ID
        function generateRoomId() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        // Function to switch between game screens
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');

            // Reset game over message visibility
            multiplayerResultsMessage.classList.add('hidden');
        }

        // Function to show custom modal
        function showCustomModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            customModalOverlay.classList.remove('hidden');
        }

        // Function to hide custom modal
        function hideCustomModal() {
            customModalOverlay.classList.add('hidden');
        }

        // Retry mechanism for Firebase operations with exponential backoff
        async function retryFirebaseCall(fn, retries = 5, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (error.code === 'unavailable' || error.code === 'resource-exhausted') {
                        // Retry on transient errors
                        console.warn(`Firebase call failed (${error.code}). Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        // Re-throw non-transient errors
                        throw error;
                    }
                }
            }
            throw new Error(`Firebase call failed after ${retries} retries.`);
        }

        // --- Game Logic (Solo & Shared) ---

        // Initializes the game state and displays a new word
        function startGame() {
            currentScore = 0;
            wrongAttempts = 0;
            updateScoreDisplay(); // Update local display
            myPlayerNameDisplay.textContent = gameMode === 'solo' ? 'Player' : myPlayerName; // Display player name
            opponentPanel.classList.toggle('hidden', gameMode === 'solo'); // Hide opponent panel in solo

            showScreen('game-screen');

            if (gameMode === 'solo') {
                pickAndDisplayWord();
            } else {
                // In 1v1, word picking/display is handled by the Firestore listener
                // The currentWordData will be loaded from the room state
                // Only show word when game state indicates it's ready
                if (gameRoomRef) {
                    // Host sets the first word, guest waits for it
                    if (myPlayerNum === 1) { // Player 1 is the host (who created or joined first)
                        // Trigger word selection only if game room is just starting or round needs new word
                        // This logic will be in the onSnapshot listener too, for robust sync
                    }
                }
            }
        }

        // Updates the score and wrong attempts display
        function updateScoreDisplay(playerScore = currentScore, playerWrong = wrongAttempts) {
            scoreDisplay.textContent = playerScore;
            wrongAttemptsDisplay.textContent = `${playerWrong}/3`;
        }

        // Selects a random word and prepares its options (for solo mode or 1v1 host)
        function pickAndDisplayWord() {
            const randomIndex = Math.floor(Math.random() * words.length);
            const selectedWord = { ...words[randomIndex] }; // Clone to avoid modifying original

            let allDefinitions = words.map(w => w.definition);
            let incorrectDefinitions = allDefinitions.filter(def => def !== selectedWord.definition);

            while (incorrectDefinitions.length < 3) {
                const randomOtherDefinition = words[Math.floor(Math.random() * words.length)].definition;
                if (!incorrectDefinitions.includes(randomOtherDefinition) && randomOtherDefinition !== selectedWord.definition) {
                    incorrectDefinitions.push(randomOtherDefinition);
                } else if (words.length <= 4) {
                    incorrectDefinitions.push(`A different meaning ${Math.random().toFixed(2)}`);
                }
            }

            shuffleArray(incorrectDefinitions);
            const distractors = incorrectDefinitions.slice(0, 3);

            let choices = [selectedWord.definition, ...distractors];
            shuffleArray(choices);

            selectedWord.shuffledOptions = choices;
            currentWord = selectedWord; // Set global currentWord for solo mode

            wordDisplay.textContent = currentWord.word;
            wordDisplay.classList.remove('correct-feedback', 'wrong-feedback');
            displayChoices();
        }


        // Renders the choice buttons
        function displayChoices() {
            choicesContainer.innerHTML = '';
            if (!currentWord || !currentWord.shuffledOptions) {
                // Handle case where word data is not yet loaded in 1v1
                wordDisplay.textContent = "Waiting for opponent...";
                return;
            }
            currentWord.shuffledOptions.forEach((option, index) => {
                const button = document.createElement('button');
                button.classList.add('choice-button', 'rounded-lg', 'text-sm', 'md:text-base');
                button.textContent = option;
                button.dataset.index = index;
                button.addEventListener('click', () => checkAnswer(option));
                choicesContainer.appendChild(button);
            });
        }

        // Checks the player's answer (for solo and 1v1)
        async function checkAnswer(selectedDefinition) {
            let isCorrect = false;
            if (selectedDefinition === currentWord.definition) {
                currentScore++;
                isCorrect = true;
                if (correctSound) correctSound.play().catch(e => console.error("Correct sound playback failed:", e));
            } else {
                wrongAttempts++;
                isCorrect = false;
                if (wrongSound) wrongSound.play().catch(e => console.error("Wrong sound playback failed:", e));
            }

            // Apply visual feedback
            if (isCorrect) {
                wordDisplay.classList.add('correct-feedback');
            } else {
                wordDisplay.classList.add('wrong-feedback');
            }

            updateScoreDisplay();

            if (gameMode === 'solo') {
                setTimeout(() => {
                    wordDisplay.classList.remove('correct-feedback', 'wrong-feedback');
                    if (wrongAttempts >= 3) {
                        endGame();
                    } else {
                        pickAndDisplayWord(); // Next word
                    }
                }, 500);
            } else {
                // 1v1 mode: Update player's state in Firestore
                await retryFirebaseCall(() => updateDoc(gameRoomRef, {
                    [`players.${currentPlayerId}.score`]: currentScore,
                    [`players.${currentPlayerId}.wrongAttempts`]: wrongAttempts,
                    [`players.${currentPlayerId}.lastAnswer`]: selectedDefinition, // Store answer for round resolution
                    [`players.${currentPlayerId}.answeredThisRound`]: true,
                    lastUpdate: new Date()
                }));
                // The `onSnapshot` listener will handle game progression
            }
        }

        // Ends the game, shows final score, and prompts for name
        async function endGame(multiplayerOutcome = null) {
            if (gameMode === 'solo') {
                showScreen('game-over-screen');
                finalScoreDisplay.textContent = currentScore;
                playerNameInput.value = '';
                multiplayerResultsMessage.classList.add('hidden');
            } else {
                // 1v1 mode: Game ends for both when one hits 3 wrongs
                if (unsubscribeGameRoom) {
                    unsubscribeGameRoom(); // Stop listening to Firestore
                    unsubscribeGameRoom = null;
                }
                showScreen('game-over-screen');
                finalScoreDisplay.textContent = currentScore;
                playerNameInput.value = myPlayerName; // Pre-fill name for leaderboard
                saveScoreButton.disabled = false; // Enable save button

                if (multiplayerOutcome) {
                    multiplayerResultsMessage.classList.remove('hidden');
                    multiplayerResultsMessage.textContent = multiplayerOutcome;
                } else {
                    multiplayerResultsMessage.classList.add('hidden'); // Should not happen in 1v1 if triggered by opponent
                }
            }
        }

        // --- Leaderboard Logic ---

        // Loads leaderboard data from local storage
        function loadLeaderboard() {
            const storedLeaderboard = localStorage.getItem('wordWarGreLeaderboard');
            if (storedLeaderboard) {
                leaderboard = JSON.parse(storedLeaderboard);
            } else {
                leaderboard = [];
            }
        }

        // Saves the current score to the leaderboard
        function saveScore() {
            const playerName = playerNameInput.value.trim();
            if (playerName) {
                leaderboard.push({ name: playerName, score: currentScore });
                leaderboard.sort((a, b) => b.score - a.score || a.name.localeCompare(b.name));
                leaderboard = leaderboard.slice(0, 10);
                localStorage.setItem('wordWarGreLeaderboard', JSON.stringify(leaderboard));
                displayLeaderboard();
                showScreen('leaderboard-screen');
                saveScoreButton.disabled = true; // Prevent multiple saves
            } else {
                showCustomModal("Oops!", "Please enter your name to save your score!");
            }
        }

        // Displays the leaderboard table
        function displayLeaderboard() {
            leaderboardBody.innerHTML = '';
            if (leaderboard.length === 0) {
                leaderboardBody.innerHTML = '<tr><td colspan="3">No scores yet!</td></tr>';
                return;
            }
            leaderboard.forEach((entry, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${entry.name}</td>
                    <td>${entry.score}</td>
                `;
                leaderboardBody.appendChild(row);
            });
            showScreen('leaderboard-screen');
        }

        // --- Music Control ---
        function toggleMusic() {
            if (musicPlaying) {
                backgroundMusic.pause();
                toggleMusicButton.textContent = "Play Music";
                musicPlaying = false;
            } else {
                backgroundMusic.volume = 0.5;
                backgroundMusic.play().then(() => {
                    toggleMusicButton.textContent = "Pause Music";
                    musicPlaying = true;
                }).catch(e => {
                    console.error("Music playback failed:", e);
                    showCustomModal("Music Error", "Autoplay blocked. Please interact with the page first or try again.");
                });
            }
        }

        // --- 1v1 Multiplayer Logic ---

        // Called when Play 1v1 button is clicked
        async function enterLobby() {
            if (!window.firebaseInitialized || !window.currentUserId) {
                showCustomModal("Loading...", "Initializing multiplayer, please wait a moment and try again.");
                return;
            }
            showScreen('lobby-screen');
            lobbyMessages.textContent = '';
            roomIdDisplay.classList.add('hidden');
            readyButton.classList.add('hidden');
            playerName1v1Input.value = `Player${Math.floor(Math.random() * 100)}`; // Suggest a random name
        }

        // Create a new game room
        async function createGame() {
            myPlayerName = playerName1v1Input.value.trim();
            if (!myPlayerName) {
                showCustomModal("Name Needed!", "Please enter your name to create a game.");
                return;
            }
            const newRoomId = generateRoomId();
            gameRoomRef = window.doc(window.db, `artifacts/${window.appId}/public/games`, newRoomId);

            try {
                await retryFirebaseCall(() => window.setDoc(gameRoomRef, {
                    status: 'waiting',
                    players: {
                        [window.currentUserId]: { name: myPlayerName, score: 0, wrongAttempts: 0, ready: false, lastAnswer: null, answeredThisRound: false }
                    },
                    currentWordData: null,
                    createdAt: new Date(),
                    lastUpdate: new Date(),
                    playerCount: 1,
                    hostId: window.currentUserId
                }));

                roomIdText.textContent = newRoomId;
                roomIdDisplay.classList.remove('hidden');
                lobbyMessages.textContent = `Game created! Share this Room ID with a friend: ${newRoomId}`;
                readyButton.classList.remove('hidden');
                myPlayerNum = 1; // I am player 1 (host)

                // Start listening for changes in this room
                listenToGameRoom();
            } catch (e) {
                console.error("Error creating game:", e);
                showCustomModal("Error", `Could not create game: ${e.message}`);
            }
        }

        // Join an existing game room
        async function joinGame() {
            myPlayerName = playerName1v1Input.value.trim();
            if (!myPlayerName) {
                showCustomModal("Name Needed!", "Please enter your name to join a game.");
                return;
            }

            const inputRoomId = await new Promise(resolve => {
                showCustomModal("Join Game", "Enter Room ID:", true); // True to indicate it's a prompt
                const inputElement = document.createElement('input');
                inputElement.type = 'number'; // Allow only numbers for room ID
                inputElement.placeholder = 'Room ID';
                inputElement.maxLength = 4;
                inputElement.classList.add('mt-4', 'mb-4', 'block', 'mx-auto', 'w-3/4'); // Tailwind classes for styling input
                modalMessage.appendChild(inputElement);

                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Join';
                confirmButton.classList.add('mt-4'); // Tailwind class
                confirmButton.onclick = () => {
                    hideCustomModal();
                    resolve(inputElement.value.trim());
                };
                modalContent.appendChild(confirmButton); // Add button to modal content directly
            });


            if (!inputRoomId || inputRoomId.length !== 4) {
                showCustomModal("Invalid Room ID", "Please enter a valid 4-digit room ID.");
                return;
            }

            gameRoomRef = window.doc(window.db, `artifacts/${window.appId}/public/games`, inputRoomId);

            try {
                const roomSnap = await retryFirebaseCall(() => window.getDoc(gameRoomRef));
                if (!roomSnap.exists()) {
                    showCustomModal("Game Not Found", "No game found with that Room ID.");
                    gameRoomRef = null;
                    return;
                }

                const roomData = roomSnap.data();
                if (roomData.playerCount >= 2) {
                    showCustomModal("Room Full", "This game room is already full.");
                    gameRoomRef = null;
                    return;
                }

                // Add this player to the room
                await retryFirebaseCall(() => window.updateDoc(gameRoomRef, {
                    [`players.${window.currentUserId}`]: { name: myPlayerName, score: 0, wrongAttempts: 0, ready: false, lastAnswer: null, answeredThisRound: false },
                    playerCount: window.getFirestore.increment(1), // Correct way to increment in Firestore
                    lastUpdate: new Date()
                }));

                lobbyMessages.textContent = `Joined game ${inputRoomId}! Waiting for host to start or for you to get ready.`;
                readyButton.classList.remove('hidden');
                roomIdText.textContent = inputRoomId;
                roomIdDisplay.classList.remove('hidden');

                // Determine my player number (if host exists)
                if (roomData.hostId) {
                    myPlayerNum = (roomData.hostId === window.currentUserId) ? 1 : 2;
                } else {
                    // If no host (shouldn't happen with current logic), default to 2
                    myPlayerNum = 2;
                }

                // Start listening for changes in this room
                listenToGameRoom();
            } catch (e) {
                console.error("Error joining game:", e);
                showCustomModal("Error", `Could not join game: ${e.message}`);
            }
        }

        // Set player as ready
        async function setReady() {
            if (!gameRoomRef) return;

            try {
                await retryFirebaseCall(() => window.updateDoc(gameRoomRef, {
                    [`players.${window.currentUserId}.ready`]: true,
                    lastUpdate: new Date()
                }));
                lobbyMessages.textContent = "Ready! Waiting for opponent...";
                readyButton.disabled = true; // Disable ready button once clicked
            } catch (e) {
                console.error("Error setting ready status:", e);
                showCustomModal("Error", `Could not set ready status: ${e.message}`);
            }
        }

        // Listen to game room changes in Firestore
        function listenToGameRoom() {
            if (unsubscribeGameRoom) {
                unsubscribeGameRoom(); // Unsubscribe from previous listener if any
            }

            unsubscribeGameRoom = window.onSnapshot(gameRoomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    console.log("Game room deleted or not found.");
                    showCustomModal("Game Ended", "The game room has been closed by the host or disconnected.");
                    resetMultiplayerState();
                    showScreen('main-menu');
                    return;
                }

                const roomData = docSnap.data();
                const players = roomData.players || {};

                // Identify my player and opponent
                const me = players[window.currentUserId];
                opponentId = Object.keys(players).find(id => id !== window.currentUserId);
                const opponent = opponentId ? players[opponentId] : null;

                if (!me) {
                    // This player is no longer in the room, likely removed by opponent leaving
                    console.log("Player removed from room.");
                    showCustomModal("Game Ended", "You have been disconnected from the game.");
                    resetMultiplayerState();
                    showScreen('main-menu');
                    return;
                }

                myPlayerName = me.name || 'You';
                currentScore = me.score || 0;
                wrongAttempts = me.wrongAttempts || 0;
                updateScoreDisplay(); // Update my local score display

                myPlayerNameDisplay.textContent = myPlayerName;

                if (opponent) {
                    opponentName = opponent.name || 'Opponent';
                    opponentPlayerNameDisplay.textContent = opponentName;
                    opponentScoreDisplay.textContent = opponent.score || 0;
                    opponentWrongAttemptsDisplay.textContent = `${opponent.wrongAttempts || 0}/3`;
                    opponentStatusDisplay.textContent = opponent.ready ? "READY!" : "Waiting...";
                    opponentPanel.classList.remove('hidden');
                } else {
                    opponentName = '';
                    opponentPlayerNameDisplay.textContent = 'N/A';
                    opponentScoreDisplay.textContent = '0';
                    opponentWrongAttemptsDisplay.textContent = '0/3';
                    opponentStatusDisplay.textContent = "Waiting for player 2...";
                    opponentPanel.classList.remove('hidden');
                }

                // Game State Logic
                if (roomData.status === 'waiting') {
                    if (me.ready && opponent?.ready) {
                        lobbyMessages.textContent = "Both players ready! Starting game...";
                        // Host (player 1) initiates the game
                        if (roomData.hostId === window.currentUserId) {
                             retryFirebaseCall(() => updateDoc(gameRoomRef, { status: 'in_progress' }));
                        }
                    } else if (me.ready) {
                        lobbyMessages.textContent = `Ready! Waiting for ${opponentName || 'opponent'} to be ready...`;
                    } else if (opponent?.ready) {
                        lobbyMessages.textContent = `${opponentName} is ready! Click Ready to start!`;
                    } else {
                        lobbyMessages.textContent = `Waiting for ${opponentName || 'opponent'} and you to be ready.`;
                    }
                } else if (roomData.status === 'in_progress') {
                    showScreen('game-screen');
                    // Ensure word data is present and displayed
                    if (roomData.currentWordData) {
                        currentWord = roomData.currentWordData;
                        wordDisplay.textContent = currentWord.word;
                        wordDisplay.classList.remove('correct-feedback', 'wrong-feedback');
                        displayChoices(); // Re-render choices
                        // Re-enable choices if both haven't answered yet
                        choicesContainer.querySelectorAll('button').forEach(button => button.disabled = false);

                    } else {
                        // If no current word, host picks one
                        if (roomData.hostId === window.currentUserId) {
                            pickAndSetNewWordForRoom();
                        } else {
                            wordDisplay.textContent = "Waiting for next word...";
                            choicesContainer.innerHTML = '';
                        }
                    }

                    // Handle round completion and next word
                    const myAnswered = me.answeredThisRound;
                    const opponentAnswered = opponent?.answeredThisRound;

                    if (myAnswered && opponentAnswered) {
                        // Both players have answered. Resolve the round.
                        // Only host (player 1) processes the answer and updates state to avoid race conditions
                        if (roomData.hostId === window.currentUserId) {
                            resolveRound(me, opponent, roomData.currentWordData.definition);
                        } else {
                             // Guest just waits for the host to update the game state
                             wordDisplay.textContent = "Waiting for results...";
                             choicesContainer.querySelectorAll('button').forEach(button => button.disabled = true);
                        }
                    } else if (myAnswered) {
                         // I have answered, waiting for opponent
                         wordDisplay.textContent = `Waiting for ${opponentName} to answer...`;
                         choicesContainer.querySelectorAll('button').forEach(button => button.disabled = true);
                    } else if (opponentAnswered) {
                        // Opponent has answered, I need to answer
                         wordDisplay.textContent = `Your turn! ${opponentName} has answered.`;
                    }

                    // Check for game over condition
                    if (me.wrongAttempts >= 3 || (opponent && opponent.wrongAttempts >= 3)) {
                        let resultMessage = "It's a tie!";
                        if (me.score > opponent.score) {
                            resultMessage = "You WIN! 🎉";
                        } else if (opponent.score > me.score) {
                            resultMessage = "You LOSE! 😭";
                        }
                        endGame(`Game Over! ${resultMessage}`);
                    }


                } else if (roomData.status === 'ended') {
                    let resultMessage = "It's a tie!";
                    if (me.score > opponent.score) {
                        resultMessage = "You WIN! 🎉";
                    } else if (opponent.score > me.score) {
                        resultMessage = "You LOSE! 😭";
                    }
                    endGame(`Game Over! ${resultMessage}`);
                }
            }, (error) => {
                console.error("Firestore listen failed:", error);
                showCustomModal("Connection Error", "Lost connection to the game room. Please check your internet.");
                resetMultiplayerState();
                showScreen('main-menu');
            });
        }

        // Host picks and sets a new word for the room
        async function pickAndSetNewWordForRoom() {
            if (!gameRoomRef || myPlayerNum !== 1) return; // Only host can do this

            const randomIndex = Math.floor(Math.random() * words.length);
            const selectedWord = { ...words[randomIndex] };

            let allDefinitions = words.map(w => w.definition);
            let incorrectDefinitions = allDefinitions.filter(def => def !== selectedWord.definition);

            while (incorrectDefinitions.length < 3) {
                const randomOtherDefinition = words[Math.floor(Math.random() * words.length)].definition;
                if (!incorrectDefinitions.includes(randomOtherDefinition) && randomOtherDefinition !== selectedWord.definition) {
                    incorrectDefinitions.push(randomOtherDefinition);
                } else if (words.length <= 4) {
                    incorrectDefinitions.push(`A different meaning ${Math.random().toFixed(2)}`);
                }
            }

            shuffleArray(incorrectDefinitions);
            const distractors = incorrectDefinitions.slice(0, 3);

            let choices = [selectedWord.definition, ...distractors];
            shuffleArray(choices);

            selectedWord.shuffledOptions = choices; // Update selectedWord with shuffled options

            try {
                await retryFirebaseCall(() => updateDoc(gameRoomRef, {
                    currentWordData: selectedWord,
                    [`players.${window.currentUserId}.answeredThisRound`]: false, // Reset answered status
                    [`players.${opponentId}.answeredThisRound`]: false, // Reset opponent's status
                    lastUpdate: new Date()
                }));
            } catch (e) {
                console.error("Error setting new word for room:", e);
                showCustomModal("Sync Error", "Could not set next word. Please try refreshing.");
            }
        }


        // Host resolves the round and updates scores/next word
        async function resolveRound(me, opponent, correctDefinition) {
            if (!gameRoomRef || myPlayerNum !== 1) return; // Only host resolves

            let myNewScore = me.score;
            let myNewWrongAttempts = me.wrongAttempts;
            let opponentNewScore = opponent.score;
            let opponentNewWrongAttempts = opponent.wrongAttempts;

            // Determine if players were correct/incorrect
            const meCorrect = me.lastAnswer === correctDefinition;
            const opponentCorrect = opponent.lastAnswer === correctDefinition;

            if (meCorrect) {
                myNewScore++;
            } else {
                myNewWrongAttempts++;
            }

            if (opponentCorrect) {
                opponentNewScore++;
            } else {
                opponentNewWrongAttempts++;
            }

            try {
                // Update both players' scores and wrong attempts in a single batch operation
                await retryFirebaseCall(() => updateDoc(gameRoomRef, {
                    [`players.${window.currentUserId}.score`]: myNewScore,
                    [`players.${window.currentUserId}.wrongAttempts`]: myNewWrongAttempts,
                    [`players.${window.currentUserId}.lastAnswer`]: null, // Clear last answer
                    [`players.${window.currentUserId}.answeredThisRound`]: false, // Reset for next round

                    [`players.${opponentId}.score`]: opponentNewScore,
                    [`players.${opponentId}.wrongAttempts`]: opponentNewWrongAttempts,
                    [`players.${opponentId}.lastAnswer`]: null, // Clear last answer
                    [`players.${opponentId}.answeredThisRound`]: false, // Reset for next round

                    lastUpdate: new Date()
                }));

                // After updating scores, check if anyone lost and pick next word if game continues
                if (myNewWrongAttempts < 3 && opponentNewWrongAttempts < 3) {
                     pickAndSetNewWordForRoom(); // Prepare next word
                } else {
                    await retryFirebaseCall(() => updateDoc(gameRoomRef, {
                        status: 'ended',
                        lastUpdate: new Date()
                    }));
                }

            } catch (e) {
                console.error("Error resolving round:", e);
                showCustomModal("Sync Error", "Could not resolve round. Please try refreshing.");
            }
        }

        // Leave the current game room and reset state
        async function leaveGameRoom() {
            if (unsubscribeGameRoom) {
                unsubscribeGameRoom(); // Stop listening
                unsubscribeGameRoom = null;
            }

            if (gameRoomRef) {
                try {
                    const roomSnap = await retryFirebaseCall(() => getDoc(gameRoomRef));
                    if (roomSnap.exists()) {
                        const roomData = roomSnap.data();
                        const players = roomData.players || {};

                        if (Object.keys(players).length === 1 && players[window.currentUserId]) {
                            // If I'm the only one left, delete the room
                            await retryFirebaseCall(() => deleteDoc(gameRoomRef));
                            console.log("Deleted empty game room:", gameRoomRef.id);
                        } else if (players[window.currentUserId]) {
                            // If others are in the room, just remove me
                            const updatedPlayers = { ...players };
                            delete updatedPlayers[window.currentUserId];
                            await retryFirebaseCall(() => updateDoc(gameRoomRef, {
                                players: updatedPlayers,
                                playerCount: Math.max(0, roomData.playerCount - 1),
                                lastUpdate: new Date()
                            }));
                            console.log("Removed player from room:", gameRoomRef.id);
                        }
                    }
                } catch (e) {
                    console.error("Error leaving/cleaning up room:", e);
                    // Don't show modal, just log, as user is navigating away
                } finally {
                    resetMultiplayerState();
                }
            }
            showScreen('main-menu');
        }

        // Reset all multiplayer-related global state
        function resetMultiplayerState() {
            if (unsubscribeGameRoom) {
                unsubscribeGameRoom();
                unsubscribeGameRoom = null;
            }
            gameRoomRef = null;
            currentPlayerId = null;
            myPlayerName = '';
            opponentId = null;
            opponentName = '';
            myPlayerNum = 0;
            opponentPlayerNum = 0;
            lobbyMessages.textContent = '';
            roomIdDisplay.classList.add('hidden');
            readyButton.classList.add('hidden');
            readyButton.disabled = false;
        }

        // --- Event Listeners ---
        window.onload = function() {
            loadLeaderboard();
            toggleMusicButton.textContent = "Play Music"; // Initial state
        };

        // Main Menu Buttons
        playSoloButton.addEventListener('click', () => {
            gameMode = 'solo';
            startGame();
        });
        play1v1Button.addEventListener('click', enterLobby);
        showLeaderboardMainMenuButton.addEventListener('click', displayLeaderboard);
        toggleMusicButton.addEventListener('click', toggleMusic);

        // Lobby Buttons
        createGameButton.addEventListener('click', createGame);
        joinGameButton.addEventListener('click', joinGame);
        readyButton.addEventListener('click', setReady);
        leaveLobbyButton.addEventListener('click', leaveGameRoom);

        // Game Over Buttons
        saveScoreButton.addEventListener('click', saveScore);
        playAgainButton.addEventListener('click', () => {
            if (gameMode === 'solo') {
                startGame();
            } else {
                // In 1v1, game state needs to be reset via Firebase
                // A simpler approach for now is to return to lobby and rejoin/create
                resetMultiplayerState();
                enterLobby(); // Go back to lobby for 1v1
            }
        });
        mainMenuFromGameOverButton.addEventListener('click', () => {
            resetMultiplayerState(); // Clean up 1v1 state if relevant
            showScreen('main-menu');
        });

        // Leaderboard Button
        mainMenuFromLeaderboardButton.addEventListener('click', () => showScreen('main-menu'));

        // Custom Modal Close Button
        modalCloseButton.addEventListener('click', hideCustomModal);

        // Play music on first overall user interaction if autoplay failed initially
        document.addEventListener('click', () => {
            if (!musicPlaying && backgroundMusic.paused) {
                backgroundMusic.volume = 0.5;
                backgroundMusic.play().then(() => {
                    toggleMusicButton.textContent = "Pause Music";
                    musicPlaying = true;
                }).catch(e => console.error("Music playback failed on user interaction:", e));
            }
        }, { once: true });
    </script>
</body>
</html>
